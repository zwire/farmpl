# パフォーマンス指針（2025-10 更新）

この文書は、現行実装の性能改善点・計測・今後の展望を整理する。

## 現状のボトルネック
- モデルサイズの膨張
  - 指数は主に `(land × crop × day)` と `(worker × event × day)`、`(resource × event × day)` の積で決まる。
  - 変数/制約のフル生成は大規模になるほどビルド時間と探索時間を圧迫。
- 段階最適化（lexicographic）で毎段モデルを再構築し直すコスト。

## 今回実施した最適化
- 変数生成のスパース化
  - event 実施可能日 `T_e` だけに `h, assign, u, r` を生成。
  - crop 占有可能日 `T_c` だけに `x, occ` を生成（uses_land が無い作物は全日）。
  - 参照側は「存在する変数だけを和に入れる」安全化で順序依存を排除。
- ウォームスタート（AddHint）
  - 段階間で `x[l,c,t] / z[l,c] / r[e,t]` のヒントを注入。
- 設定の外出し
  - `SYNC_TIMEOUT_MS`, `CP_NUM_WORKERS` を `core/config.py` から制御。
- メトリクス出力
  - `PlanDiagnostics.stages[].{vars, build_ms, solve_ms}` を追加。ビルド時間/探索時間/主要変数数を確認可能。

## 期待効果（経験則）
- スパース化: 2〜5倍、条件によっては 5〜10倍の短縮が見込める。
- ウォームスタート: 後段の収束を 1.2〜2倍程度改善。
- 並列化（`CP_NUM_WORKERS`）: コア数に応じて探索時間短縮（問題構造に依存）。

## 運用ヒント
- 並列度
  - `CP_NUM_WORKERS=0`（自動検出）が既定。明示的に 8/16 など設定して A/B を推奨。
- 時間制限
  - `SYNC_TIMEOUT_MS` をユースケースに合わせて調整。段階数が多いほど余裕を持たせる。
- メトリクスの読み方
  - `vars` に `x_lct, h_wet, u_ret, ...` を集計。急増している次元を優先的に削る。
  - `build_ms` と `solve_ms` のどちらが支配的かで「再定式化」か「ヒューリスティック/並列化」かの優先度を判断。

## 将来展望（さらに10倍級を狙う）
- 区間（IntervalVar）モデル化
  - 連続占有を bool 時系列ではなく区間で表現し、累積/前後関係で制約。変数・制約が桁で減る可能性。
- 割当の集約
  - 役割不要イベントは `h_total[e,t]` だけに圧縮し、必要なイベントのみ個別 `assign[w,e,t]` を保持。
- 事前フィルタ強化
  - `T_e` の導出に頻度・ラグの厳密化、タグ/土壌条件等で `T_c` をさらに縮小。
- 分割統治
  - 土地/作物群でサブ問題化し、上位で緩結合（上限制約/価格ペナルティ）する。

## 言語移行（C#/Rust）の位置づけ
- 効果が大きいのは「モデル生成が支配的」なケース。
  - Python→C#（Google.OrTools）/C++ 相当で 3〜10倍のビルド高速化が期待できる。
  - ただし探索は C++ コアが支配するため、探索時間優位は限定的。再定式化やスパース化と併用が前提。

## チェックリスト（実データ検証）
- [ ] `diagnostics.stages` を保存し、`vars/build_ms/solve_ms` の推移を把握
- [ ] `CP_NUM_WORKERS` を数パターン試す（0, 8, 16 ...）
- [ ] 制約ON/OFFでの変数数の差分を比較（どの制約が効いているか）
- [ ] 収束品質（目的値・可行性）に対する影響を確認

---
最小コストで効く順は「スパース化 → 並列/ウォームスタート → 区間化/再定式化」。本ドキュメントは継続的に更新する。
